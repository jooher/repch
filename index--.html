<!DOCTYPE html>
<html>
<head>
	<title>repch</title>
	
	<meta name="viewport" content="width=device-width, initial-scale=1" /> 
	<link rel="stylesheet" href="style.css"/>
	
	<script>
	"use strict";

	const

	Starbar	= function(proto,bars){

		proto.appendChild(proto.cloneNode(false));
		
		const	setvalue= (n,value)=>{
				const	v = value*n.clientWidth,
					w = Math.floor( bars ? v/bars : v );
				n.firstChild.style.width = w+"px";
				n.value=value;
			},
			
			onclick	= e=>{	const	ex	=e.offsetX,
						n	=e.target,
						nw	=n.clientWidth,
						r	=ex/nw,
						value	=bars ? Math.ceil(r*bars) : r;
						
					setvalue(n,value);
				},

			starbar	= (value,enabled)=>{
				const	n=proto.cloneNode(true);
				if(enabled)n.addEventListener("click",onclick);
				setTimeout(()=>{setvalue(n,value);},10);
				return n;
			}
			
		return	{
			disabled: value=>starbar(value),
			enabled	: value=>starbar(value,true)
		}
	},
		
	Persist	=(storage,box,unbox)=> // keeps the data coherent among several tabs
		key	=>{
			let	order=[],
				index={},
				stamp=-1,
				stampname=key+"_stamp";
				
			const	ixrow	= r=>(index[r[key]]=r)&&false||ix,
				ixset	= s=>s.length&&s.reduce&&s.reduce(ixrow),
				anew	= s=>(index={})&&ixset(order=s&&s.reduce?s:[]),
				update	= _=>++stamp&&!delay&&sync(),
				sync	= i=>{
					const saved=parseInt(storage.getItem(stampname))||0;
					if(saved<stamp){ //save
						order=order.filter(r=>index[r[key]]==r);
						storage.setItem(key,box(order));
						storage.setItem(stampname,stamp);
					}
					if(saved>stamp){ //load
						anew(unbox(storage.getItem(key)));
						stamp=saved;
					}
				};
				
			return	{
				take	: m => index[m],
				save	: r => order.push(r)&&ixrow(r),
				
				filter	: h => {
						let rows=order;
						for(let f in h)if(f)rows=rows.filter(r=>r[f]==h[f]);
						return rows;
					}
			}
		};

	</script>
	
	
</head>

<body>


<script>// src="0.4.js"

	"use strict";

	const	edit	= what	=>'what contenteditable'.d("!! dict.editable.what@title .what@").ui(".what=#:text").FOR({what}),
		input	= what	=>'INPUT.what'.d("!! dict.editable.what@placeholder .what@value").ui(".what=#:value").FOR({what}),
		credit	= 'credit'.d("! $!=.credit:starbar.enabled").ui(".credit=$!.value")
		
		dataset	= (tags,raws)=>raws.map( raw=>{const row={};tags.forEach((t,i)=>row[t]=raw[i]); return row;} )
	;

	'client'.d("	$tab= $Entity=; $entries= $aspects= $entities= $opinions= $cats= $lists= $listentities="
/*
			$entries=(`entry)db
			$aspects=(`aspect)db
			$entities=(`entity)db
			$opinions=(`opinion)db
			$cats=(`cat)db
			$lists=(`list)db
			$listentities=(`listentity)db
*/	
		,'ARTICLE.misc'.d(""
		
			,'tabs'.d("* dict.tabs@"
				,'tab'.d("! .title; a!").a("!? (.tab $tab)eq@selected").ui("$tab=.tab")
			)
			
			,'SECTION.top'.d("? $tab"
			
				,'lists'.d("?? $tab@lists; $list="
					,'HEADER'.d(""
						,'SELECT'.d("*@ (`list)db"
							,'OPTION'.d("!! .title@ .list@value")
						).ui("$list=#:value")
						,'BUTTON.addlist'.ui("? .title=(dict.prompt.addlist)prompt; $lists=($list=()uid .title)db")
					)
					,'UL.entities'.d("? $list; * (`listentity $list)db"
						,'LI'.d("? .pos; * (.entity)db; ! .title").ui("$Entity=$")
					)
				),
				
				,'cats'.d("?? $tab@cats; $cat="
					,'HEADER'.d(""
						,'SELECT'.d("*@ (`cat)db"
							,'OPTION'.d("!! .title@ .cat@value")
						).ui("$cat=#:value")
						,'BUTTON.addcat'.ui("? .title=(dict.prompt.addlist)prompt; $cats=($cat=()uid .title)db")
					)
					,'UL.entities'.d("? $cat; * (`entity $cat)db"
						,'LI'.d("? .pos; ! .title").ui("$Entity=$")
					)
				),
				
				,'settings'.d("?? $tab@settings"
					,'BUTTON.clear'.d("! `Clear").ui("storage.clear")
				)
			
			)
		)

		,'ARTICLE.entity'.d("? $Entity; * $Entity@; $?="
				
			,'SECTION.tags'.d("$lists; * (`list)db"
				,'tag'
				.d("! .title; $tagged=(.listentity=(.list .entity=$Entity.entity)~)db $?=$tagged.pos; a!")
				.a("!? $?@tagged")
				.ui("
					$?=$?:! .pos=; {? $? .pos=()uid};
					$tagged=(.listentity .list .entity .pos)db;
					$listentities=()
				")

			)			
			
			,'SECTION.editables'.d(""
				,input("title")
				,input("desc")
				,'general'.d("! Aspect")
			).u("(`entity $)db")
			
			//,'BUTTON.bindto'.d("! `Bind")
		
/*				,'SELECT.category'
				.d("? $entity.aspects:!; hint dict.entity.category; Options(mock.categories:)")
				.ui(".aspects=#:value")
			,'aspects'.d("Aspects($entity.aspects)")
*/			

			,'BUTTON.moreinfo'.d("? $?:!").ui("$?=:!")
			,'BUTTON.lessinfo'.d("? $?").ui("$?=")
			
			,'SECTION.details'.d("? $?"
				,'aspects'.d("* (`opinion .entity)db"
					,'opinion'.d("! Aspect").u("(@opinion $)db")//$opinions=
				)
				,'opinion'.d("$?="
					,'BUTTON.addaspect'.d("? $?:!").ui("$?=:!")
					,'SELECT.name'
					.d("? $?; hint dict.entity.aspects; * mock.aspect; Option(.aspect@value)")//; #:focus
					.ui(".aspect=#:value (.opinion=(.entity .aspect)~ .entity .aspect)db $?=")//$opinions=()
				)
			)
			

		)

		,'ARTICLE.find'.d("" //,'4627073803671'	
			,'SECTION.entry'.d("$entry="
				,'INPUT.key'.ui("log $entry=#:value,prefix")
				,'BUTTON.scan'.ui("(`scan)alert")
			).u("
			? $entry;
			? .Entry=($entry)db .Entry=($entry .entity=()uid)db;
			? $Entity=(.Entry.entity)db $Entity=(.Entry.entity)db"
			)
			
		)
		
	)

	.DICT({
	
		Aspect	: 'aspect'.d("$?="
				,'summary'.d(""
					,'name'.d("! .aspect").ui("$?=$?:!; ?")
					,'IMG.stats'.d()
					,credit
				)
				,'notes'.d(""
					,'public'.d("? $?; ? .ref; * (`ls:notes .ref)uri:query"
						,'note'.d("! .note").ui("..note=. ..publicnote=.")
					)
					,'note contenteditable'.d("? (.note $?)?; ! .note").ui(".note=#:text")//? (.note .publicnote:!)?;
				).u("$?=")
			),					

		Options	: 'OPTGROUP'.d("! (.selected:! Hint)!; * .options@value; Option( .value ..selected )"), 
		Option	: 'OPTION'.d("!! (.label .value)? .value (.value .selected)eq@selected"),
		
		tabs	:{
		
	
			
		},
		
		
		entries	:{pkey:"entry"},	// entry(method,word):entity
		aspects	:{pkey:"aspect"},	// aspect: title
		entities:{pkey:"entity"},	// entity: title,aspects
		opinions:{pkey:"about"},	// about(entity,aspect): entity, aspect, credit, note
		lists	:{pkey:"list"},		// list: title
		cats	:{pkey:"cat"},		// cat: title
		listentities:{pkey:"listentity"}, // listentity: pos
		
		method	:['barcode','uri'],

		mock	:{
			aspect:['general','taste','nutrition','ethic']
		},
		
		dict	:{
			barcode	:"barcode",
			editable:{
				title	:"Entity title",
				credit	:"Credit",
				note	:"Note",
				aspects	:"Applicable aspects"
			},
			prompt	:{
				addlist	:"Создать список:",
				addcat	:"Создать категорию:"
			},
			tabs	: dataset(
					["tab","title"],
					[["lists","Списки"],["cats","Категории"],["settings","Настройки"]]
				)
		},
		

	})
	
	.FUNC({
		operate	:{
			hint	:(value,alias,node)=>{node.setAttribute("placeholder",value)},
			storage	:{
				clear	:()=>confirm("Clear all local data?")&&localStorage.clear()
			}
		},
		flatten	:{
			"~"	:values=>values.join(":"),
			trace	:(values,names)=>console.log(values.map((v,i)=>names[i]+": "+v).join("; "))
			db	:(function(){ // dap wrapper for Persist object
				
					const	P	=Persist(localStorage,dap.Env.Json.encode,dap.Env.Json.decode),
						T	=(tables=> key=>tables[key]||(tables[key]=P(key)) )({});
						
						filter	=(rows,values,tags)=>{
							let rows=table.data(),i=values.length
							while(i--){
								const f=tags[i],m=values[i];
								rows=rows.filter(r=>r[f]==m);
							}
							return rows;
						},
						save	=(table,values)=>{
							values.forEach(r=>tables.save(r));
							return table.data();
						},
						join	=()
					
						
						
					return	(values,tags)=>{
						/*	
						( `key )db		=> T("key")				// !a v	=>T(v)
						( `key $details $x )db	=> T("key").filter({details,x})		// !a v	=>T.filter

						( @key $ )		=> T("key").save($)			// a !v	=>T(a).save
						
						( $key `join )db	=> T("key").take(key)			// a v	=>T(a).take(v)
						( $key $details )db	=> T("key").save({key,details}) 	// a v	=>T.save
						*/	
						const	v=values.pop(),
							c=values.length,
							t=tags[c-1],
							a=tags[c];
						
						if(!a)return filter(T(v),values,tags);
						if(!v)return save(T(a),values);
						if(!t)return join(T(a).take(v),values,tags);
							
						T(a).save(dap.Util.hash(values,tags),v)
					}
				})(),
				
			uid	:(function(){
					let seed=parseInt(localStorage.getItem("next")||"1");
					return present=>{
						if(present)return present;
						localStorage.setItem("next",++seed);
						return seed;
					}
				})()

		},
		convert	:{
			starbar	: Starbar(document.createElement("stars"),10),
				
			prefix	:key=>
				key.match(/^https?\:/)?key:
				key.match(/^\d{13}$/)?"ean:"+key:
				alert("Can't recognize key format")
		}
	})
	
	.FUNC(Persist)
	
	.RENDER()

	</script>

</body>
</html>
<script>
/*
server	History{

	table	Stakes{
		>Forum,Author,Item
		Credit : -1.0 .. +1.0
		Stake : 0.0 .. 1.0
		Time
	}
	
	table	Forums{
		>Forum
		Trust = 0.0 .. +1.0
	}
}

const

local=(()=>{
	
	const
	Aspects = table("aspect: title"),
	Entities= table("entity: title"),
	Opinions= table("entity, aspect: credit, note");
	
	return	{
		
		get	:{
			aspects :$=>Aspects.order({pref:'-'}),
			credits	:$=>Credits.where({$.aspect}).join(Entities),
		},
		
		put	:{
			entity	:$=>Entities.update($),	//entity,title
			credit	:$=>Credits.update($),	//entity,aspect,credit,note
		}
	}
	
})();


const

Forum=(()=>{
	
	function
	δ( Bets|Credit b, Item|Credit i ) = ( i - b)²,
	
	const
	Authors	= table("author: oauth: title"),
	Entries	= table("method,key: entity"),
	Entities= table("entity: title"),
	Aspects	= table("aspect: title"),
	Items	= table("item: aspect,entity: credit,weight"),
	Bets	= table("bet: author,aspect,entity: credit,stake,bonus,reward,date"),
	Trusts	= table("trust: author,aspect: weight");
	
	return	{
		
		Bet	:(author,aspect,entity,credit,stake)=>{
			
			let	weight	= Trusts{author,aspect}.weight,
				bonus	= D(credit, Items{aspect,entity}.credit);
			
			if(weight>0)
				Items{aspect,entity} .credit+=credit*weight, .weight+=weight;
			
			Bets{author,aspect,entity} credit,stake,bonus;
		},
		
		Trust	:(author,aspect)=>{
			
			Bets{author,aspect}
				reward	= Sum .reward = .bonus - tau*D(credit,Items{aspect,.entity}.credit) / .stake; // ???
				
			Trusts{author,aspect} weight+=reward;
		},
		
	}
})
*/
</script>

