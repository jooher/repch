<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>repch</title>
	
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0" /> 
	<link rel="stylesheet" href="material.css"/> 
	<link rel="manifest" href="manifest.json"/>
	
	<link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
		
	<script src="barkodnik.js"></script>
	<script src="untab-.js"></script>
	
	<script>
	if(navigator.serviceWorker)
		window.addEventListener('load', e=>
			navigator.serviceWorker.register('service-worker.js')
			.then(registration=>console.log('Registered!'),err=>console.log('Registration failed: ', err))
			.catch(err=>console.log(err))
		)
	else
		console.log('service worker is not supported');
	</script>
	
	<script>
	"use strict";

	const
	
	uid	= ((storage,uidkey)=>{
			let last=parseInt(storage.getItem(uidkey)||"1");
			return n=>n||storage.setItem(uidkey,++last)||last;
		})(localStorage,"uid"),
		
	textOnly	= e => {
		e.stopPropagation();
		e.preventDefault();
		e.target.textContent=(e.clipboardData||window.clipboardData).getData('Text');
	},
	
	Starbar	= function(proto,bars){

		proto.appendChild(proto.cloneNode(false));
		
		const	setvalue= (n,value)=>{
				const	v = value*n.clientWidth,
					w = Math.floor( bars ? v/bars : v );
				n.firstChild.style.width = w+"px";
				n.value=value;
			},
			
			onclick	= e=>{	const	ex	=e.offsetX,
						n	=e.target,
						nw	=n.clientWidth,
						r	=ex/nw,
						value	=bars ? Math.ceil(r*bars) : r;
						
					setvalue(n,value);
				},

			starbar	= (value,enabled)=>{
				const	n=proto.cloneNode(true);
				if(enabled)n.addEventListener("click",onclick);
				setTimeout( _=>setvalue(n,value),10);
				return n;
			}
			
		return	{
			disabled: value=>starbar(value),
			enabled	: value=>starbar(value,true)
		}
	},
	
	Persist	=(storage,box,unbox,single)=> // keeps the data coherent among several tabs
		key	=>{
			let	order=[],
				index={},
				stamp=-1,
				stampname=key+"_stamp";
				
			const
			ixrow	= r=>index[r[key]||(r[key]=uid())]=r,
			ixset	= s=>{ s.forEach&&s.length&&s.forEach(ixrow); },
			flush	= _=>{
					order=order.filter(r=>index[r[key]]==r);
					storage.setItem(key,box(order));
					storage.setItem(stampname,stamp);
				},
			anew	= s=>{ index={}; ixset(order=s&&s.reduce?s:[]); ++stamp; flush(); },
			sync	= r=>{
				if(stamp>0&&single&&!r)return;
				const saved=parseInt(storage.getItem(stampname))||0;
				if(stamp<saved){ //load
					anew(unbox(storage.getItem(key)));
					stamp=saved;
				}
				if(r){
					order.push(r);
					ixrow(r);
					stamp++;
				}
				if(stamp>saved){ //save /// TODO: delay this stuff to page leave/enter
					flush();
				}
			};
				
			return	{
				data	: _ => sync()	||order,
				take	: m => sync()	||index[m],
				save	: r => sync(r)	||r,
				anew
			}
		}

	</script>
	

</head>

<body>

<div id="content">

	<article id="help">
		<h3>Repch.io</h3>
		<p>Repch.io is an anonymous social network, that allows to gather and share the impressions.</p>
	</article>
	
	<article id="welcome">
		<h3>Welcome to Repch.io</h3> 
		<p>Keep track of your impressions from the things around you: the products you buy, places you visit, books you read, websites you surf, or even people you know! All in one app!</p>
		<p>Ever been dissatisfied with a product you bought? Or, otherwise, extremely happy with it? Scan its code, rate it, and next time you'll be aware. Refer to your own records and records from other people, before showing your money!</p>
		<p>A website, a movie, a venue, a book... whatever you've contacted with and want to give a feedback — you can do it with a single tap now. Or, if you feel like, provide a detailed report why you loved or hated your interaction.</p>
		<p>Experiences of thousands of us are collected anonymously and statistically agregated to aware all of us from what's bad — and promote what's good!</p>
<!--
		<h4>Can I trust it?</h4>
		<p>Unlike many of ratings scattered around in the Internet, where you can't actually be sure that the rating is "real" (not spinned up by the seller or pushed down by competitors), Repch.io works on other principles. Our algorithms evaluate the reputation of each voter, based on all their previous feedbacks, and their correlation to The Truth. This reputation is the main asset of a voter in Repch.io. It is hard to earn, and easy to lose. Those who don't have much reputation can't really influence the rating. Those who have reputation, will not risk it by posting falsey votes. If they do, the falsey vote will have a very short effect and will be corrected by other votes very quickly, so it simply doesn't worth it.</p>
		<h4>What is The Truth?</h4>
		<p>There's only one criterion for thruth, when it comes to evaluation of a thing's worthness: the totality of people's voices. However the weight of each voice is individual and calculated from the voter's reputation.</p>
-->
	</article>
	
	<article id="promo">
		<h3>Recommended stuff</h3>
	</article>
	
	<article id="about-lists">
		<h3>Lists</h3>
		<p>Lists help you organize your items. Any item can be added to any number of lists. Add new list with the + button.</p>
	</article>
	
	<article id="about-listitems">
		<h3>List items</h3>
		<p>To add an item to the list, go to the item details, and toggle the list name marker.</p>
	</article>
	
	<article id="about-recent">
		<h3>Recent items</h3>
		<p>Here, you will see items you recently interacted with.</p>
	</article>

</div>

<!--
<div id="scanner">
	<video></video>
	<canvas></canvas>
	<button class="cancel"/>
	<div class="buttons">
		<button class="stop"/>
	</div>
</div>

-->

<script src="0.4.js"></script>

<script>

	"use strict";

	const	edit	= what =>'what contenteditable tabindex=0'.d("! .what@").ui(".what=#:text").FOR({what}), //!! dict.editable.what@title 
		input	= what =>'INPUT.what'.d("!! dict.editable.what@placeholder .what@value").ui(".what=#:value").FOR({what}),
		
		grab	= src	=> [...src.children].reduce((a,n)=>{if(n.id)a[n.id]=src.removeChild(n); return a},{}),

		dataset	= (tags,raws)=>raws.map( raw=>{const row={};tags.forEach((t,i)=>row[t]=raw[i]); return row;} ),
		
		db	=(function(){ // dap wrapper for Persist object
					
				const	P	= Persist(localStorage,dap.Env.Json.encode,dap.Env.Json.decode,true),
					tables= {},
					T	= key=> tables[key]||(tables[key]=P(key)),
					detach= r=> {r=Object.assign({},r);if(r[""])delete r[""];return r},
					filter= (data,values,tags)	=> !values.length?data:values.reduce((a,v,i)=>a.length?a.filter(r=>r[tags[i]]==v):a,data),	// :[]
					join	= (row,values,tags)	=> row&&Object.assign({}, row, ...values.map((v,i)=>T(tags[i]).take(v))),	// :{}
					save	= (table,values)		=> values.forEach(r=>table.save(detach(r)))||table.data(),
					reset	= (values,tags)		=> values.length 
						? values.forEach((v,i)=>T(tags[i]).anew(v))
						: Object.keys(tables).forEach(t=>tables[t].anew());
					
					
				return	(values,tags)=>{
					const	v=values.pop(),
						c=values.length,
						t=tags[c-1],
						a=tags[c];
						
					return	!a&&!v ? reset(values,tags) :			// ( @ ... ) anew... 
							!a ? filter(T(v).data(),values,tags) :				// ( `key $x $y ... )
							!v ? save(T(a),values) :						// ( @key $row1 $row2 ... )
							!t ? c?T(a).take(v):join(T(a).take(v),values,tags) :		// ( $key `t1 `t2 ... )
							values.push(v) && T(a).save(dap.Util.hash(values,tags));	// ( $key $x $y ... )
				}
			})()
		
	;

	'client'.d("$tab= $Entity=; $entries= $aspects= $entities= $opinions= $cats= $lists= $listentities="
	
		,'PAGE.nav'.d(""
		
			,'ROOF'.d(""
				,'tabs'.d("*@tab :split`recent,lists,categories"//
					,'tab'.d("!class .tab; a!").a("!? (.tab $tab)eq@selected").ui("$tab=.tab")
				)
				.u("?? $tab@recent; $lists= $entities=( (`entity)db @timestamp`dsc )sort")
				.u("?? $tab@lists; $entities= $lists=(`list)db")
				
				,'ICON.settings'.ui("$Entity=")
			)
			
			,'WALL'.d(""
			
				,'lists'.d("? $lists; $list="
					,'UL'.d("*@ $lists"
						,'LI'.d("! .title; a!")
						.a("!? (.list $list)eq@selected")
						.ui("$list=. $entities=(`listentity $list)db")//
					)
					,'BUTTON.add'.ui("? .title=(dict.prompt.addlist)prompt; $lists=(@list (.title))db")
				)
				
				,'entities'.d("? $entities"
					,'UL.entities'.d("; *@ $entities"
						,'LI'	.d("? (.tagged `-)ne; $=(.entity)db; ! (.title .fallback)?; !? .title:!@fallback")//? .tagged;
							.a("!? ($ $Entity)eq@selected")
							.ui("$Entity=$")
					)
				)
				
				,'hint'
					.d("? ($lists:!! $entities:!!)!; ! html.welcome")
					.d("? ($lists:!! $entities:?!)!; ! html.about-recent")
					.d("? $lists:?!; ! html.about-lists")
					.d("? ($lists:?? $entities:!)!; ! html.about-listitems")
			)
			
			,'VAULT'.d("$?= $entry="
				,'INPUT.key'.d("textonly").ui("log $entry=#:value,scope.guess")
				,'BUTTON.scan'.ui("log $entry=#:scan,scope.guess")
		
			).u("? $entry; ? .Entry=($entry)db .Entry=($entry .entity=():?uid)db; ? $Entity=(.Entry.entity)db $Entity=(.Entry.entity $entry@fallback .timestamp:timestamp)db") /// <--tweak this
		)
		
		,'PAGE.other'.d("? $Entity:!; scroll #; $tab="
		
			,'ROOF'.d(""
				,'tabs'.d("*@tab :split`help,data"//
					,'tab'.d("!class .tab; a!").a("!? (.tab $tab)eq@selected").ui("$tab=.tab")
				)
			)
			
			,'WALL'
			.d("? $tab:!; ! html.promo")
			.d("?? $tab@data"
				,'cleardb'.d("! `Clear").ui("? (dict.cleardb)confirm; (@)db")
			)
			.d("?? $tab@help; ! html.help")
			
		)
		
		,'PAGE.entity'.d("? $Entity; scroll #; * $Entity@"
		
			,'ROOF'.d(""
				,'ICON.share'.ui("( `share )alert")
			)
			
			,'WALL'.d(""
			
				,'editables'.d(""
					,edit("title").d("textonly; focus .title:!")
					,edit("desc").d("textonly; focus (.title .desc:!)!")
				).u("(@entity $)db")
				
				,'SECTION.tags'.d("$lists; * (`list)db"
					,'tag'
					.d("! .title; .?=(.listentity=(.list .entity=$Entity.entity)|)db $tagged=.?.; a!")
					.a("!? $tagged")
					.ui("(.listentity .list .entity $tagged:?uid=$tagged:!)db")
				)
				
				,'SECTION.entries'.d("* (`entry .entity)db"
					,'A.entry target=_blank'.d(".href=.entry:scope.href; !! .entry@ .href .href@title")
				)
				
				,'SECTION.opinions'.d("$?="
				
					,'present'.d("$opinions; * (`opinion .entity)db"
						,'opinion'.d("! Aspect").u("(@opinion $)db")
					)
					
					,'append'.d("? $aspects=((@custom`aspects)db).0.value $aspects=(`static/aspects.txt? .entity)uri:query; $edit="
					
						,'UL.addaspects'
							.d("? $edit:!; $!=; *@ $aspects:untab; ! AddAspect")//@items
							.u("$?= .aspect=$!. $opinions=( (.entity .aspect)|@opinion .entity .aspect)db; { ? .desc:!; .desc=$!.category (`entity $)db }; $!=")//$opinions=()
							
						,'TEXTAREA'.d("? $edit; ! $aspects").ui("( @custom`aspects $aspects=#:value@value )db")
						
						,'BUTTON'.d("!class ($edit:# @+`done @-`edit)case").ui("$edit=$edit:!")
					)
				)
			)
		)
	)

	.DICT({
		
		Aspect	: 'aspect'.d("$?="
				,'summary'.d(""
					,'name'.d("! .aspect").ui("$?=$?:!; ?")
					,'IMG.stats'.d()
					,'credit'.d("! $!=.credit:starbar.enabled").ui("$?=.credit=$!.value")
				)
				,'notes'.d(""
					,'public'.d("? $?; ? .ref; * (`notes .ref)db"
						,'note'.d("! .note").ui("..note=. ..publicnote=.")
					)
					,'note contenteditable'
						.d("? (.note $?)?; ! .note; focus (.note:! $?)!")
						.ui(".note=#:text")//? (.note .publicnote:!)?;
				).u("$?=")
			),

		AddAspect	: 'LI.aspect'.d("$?="
				,'name'.d("? .0:!; ! .1").ui("$!=($! (.1@aspect ..1@category) )?")
				,'category'.d("? .0; ! .1").ui("$?=$?:!; ?")
				,'UL.aspects'.d("? $?; * .0@; ! AddAspect")
			),

		Options	: 'OPTGROUP'.d("! (.selected:! Hint)!; * .options@value; Option( .value ..selected )"), 
		Option	: 'OPTION'.d("!! (.label .value)? .value (.value .selected)eq@selected"),
					
		dict	:{
			cleardb	:"Sure to clear all data?",
/*			barcode	:"barcode",
			editable:{
				title	:"Entity title",
				credit:"Credit",
				note	:"Note",
				aspects	:"Applicable aspects"
			},
			
			tabs	: dataset(
					["tab","title"],
					[["lists","Списки"],["cats","Категории"],["settings","Настройки"]]
				)
			*/
		},
		
		html	:grab(document.getElementById("content"))

	})
	
	.FUNC({
		operate	:{
			hint	:(value,alias,node)=>{node.setAttribute("placeholder",value)},
			storage	:{
				clear	:()=>confirm("Clear all local data?")&&localStorage.clear()
			},
			focus:(value,alias,node)=>{if(value)window.setTimeout(()=>{node.focus()},1000)},
			scroll:(value,alias,node)=>{
					if(value);
					window.setTimeout(()=>{
						//node.offsetParent.parentNode.scrollLeft=node.offsetLeft;
						node.scrollIntoView({behavior:"smooth",inline:"end"});
					},200);
				},
			textonly:(value,alias,node)=>node.addEventListener('paste', textOnly)

		},
		flatten	:{ db,
			"|"	:values=>values.join(":"),
			trace	:(values,names)=>console.log(values.map((v,i)=>names[i]+": "+v).join("; ")),
			
			sort	:(ops=>
					(values,names)=>values.reduce((a,v,i)=>v?ops[v](a,names[i]):a,values.pop())
				)({
					asc	:(a,v)=>a.sort((x,y)=>x[v]-y[v]),
					dsc	:(a,v)=>a.sort((x,y)=>y[v]-x[v])
				})
		},
		convert	:{
		
			untab,
			
			starbar	: Starbar(document.createElement("stars"),10),
			"?uid"	: bool	=> bool?uid():"-",
			split		: str		=> str.split(/,/g),
			share		: data	=> window.navigator.share ? window.navigator.share(data) : alert("Can't share"),
			
			
			timestamp	: _ => +Date.now(),
			
			scope		:(function(){
					const
						web	=[
								[ /^(?:www.youtube.com\/watch\?v=)([a-zA-Z0-9-]+)/, "youtube"],
								[ /^(?:youtu.be\/)([a-zA-Z0-9-]+)/, "youtube"],
								[ /^(?:www.facebook.com\/)([^?]+)/, "facebook" ]
							],
							
						nonweb={
								EAN13		:/^\d{13}$/
							},
							
						redir	={
								EAN13		: gtin=>"http://srs.gs1ru.org/id/gtin/"+gtin,
								youtube	: v	=>"https://youtu.be/"+v, // https://www.youtube.com/watch?v=
								facebook	: id	=>"https://www.facebook.com/"+id
							};
						
					return	{
					
						guess	: entry => {
						
							if(entry.startsWith("https://")){
								const	key=entry.substring(8);									
								for(let i=web.length; i--;){
									const match=web[i][0].exec(key);
									if(match)return web[i][1]+":"+match[1];
								};
								return decodeURI(entry);
							}
						
							const	parts	= entry.split(":"),
								key	= parts.pop(),
								f	= parts.length&&parts.pop();
								
							if(f)return key.match(nonweb[f])?entry:console.log("format mismatch:"+entry);
							else for(let f in nonweb)if(key.match(nonweb[f]))return f+":"+key;
							console.log("Can't recognize key format");
						},
						
						href	: entry =>{
							const parts	= entry.split(":"),
								urltp	= redir[parts[0]];
							return urltp ? urltp(parts[1]) : parts[1];
						}
					};
				})(),
				
			scan	: _ =>dap.Async(Barkodnik.Execute())
		}
	})
	
	.FUNC(Persist)

	.RENDER()

	</script>

</body>
</html>
<script>
</script>