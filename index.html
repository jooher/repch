<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>repch</title>
	
	<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=0" /> 
	<link rel="stylesheet" href="style.css"/> 
	<link rel="manifest" href="manifest.json"/>
	
	<script>
	"use strict";

	const
	
	Starbar	= function(proto,bars){

		proto.appendChild(proto.cloneNode(false));
		
		const	setvalue= (n,value)=>{
				const	v = value*n.clientWidth,
					w = Math.floor( bars ? v/bars : v );
				n.firstChild.style.width = w+"px";
				n.value=value;
			},
			
			onclick	= e=>{	const	ex	=e.offsetX,
						n	=e.target,
						nw	=n.clientWidth,
						r	=ex/nw,
						value	=bars ? Math.ceil(r*bars) : r;
						
					setvalue(n,value);
				},

			starbar	= (value,enabled)=>{
				const	n=proto.cloneNode(true);
				if(enabled)n.addEventListener("click",onclick);
				setTimeout( _=>setvalue(n,value),10);
				return n;
			}
			
		return	{
			disabled: value=>starbar(value),
			enabled	: value=>starbar(value,true)
		}
	},
	
	uid	= ((storage,uidkey)=>{
			let last=parseInt(storage.getItem(uidkey)||"1");
			return n=>n||storage.setItem(uidkey,++last)||last;
		})(localStorage,"uid"),
		
	Persist	=(storage,box,unbox,single)=> // keeps the data coherent among several tabs
		key	=>{
			let	order=[],
				index={},
				stamp=-1,
				stampname=key+"_stamp";
				
			const
			ixrow	= r=>index[r[key]||(r[key]=uid())]=r,
			ixset	= s=>s.forEach&&s.length&&s.forEach(ixrow),
			anew	= s=>(index={})&&ixset(order=s&&s.reduce?s:[]),
			update	= x=>++stamp&&!delay&&sync(),
			sync	= r=>{
				if(stamp>0&&single&&!r)return;
				const saved=parseInt(storage.getItem(stampname))||0;
				if(stamp<saved){ //load
					anew(unbox(storage.getItem(key)));
					stamp=saved;
				}
				if(r){
					order.push(r);
					ixrow(r);
					stamp++;
				}
				if(stamp>saved){ //save
					order=order.filter(r=>index[r[key]]==r);
					storage.setItem(key,box(order));
					storage.setItem(stampname,stamp);
				}
			};
				
			return	{
				data	: _ => sync()	||order,
				take	: m => sync()	||index[m],
				save	: r => sync(r)	||r
			}
		}
	</script>
	
	<script>
	if(navigator.serviceWorker)
		window.addEventListener('load', e=>
			navigator.serviceWorker.register('service-worker.js')
			.then(registration=>console.log('Registered!'),err=>console.log('Registration failed: ', err))
			.catch(err=>console.log(err))
		)
	else
		console.log('service worker is not supported');
	</script>

</head>

<body>

<div id="content">

	<div id="welcome">
		<h1>Welcome to Repch.io</h1>
	</div>

</div>

<script src="scan.js"></script>
<script src="0.4.js"></script>

<script>

	"use strict";

	const	edit	= what =>'what contenteditable'.d("!! dict.editable.what@title .what@").ui(".what=#:text").FOR({what}),
		input	= what =>'INPUT.what'.d("!! dict.editable.what@placeholder .what@value").ui(".what=#:value").FOR({what}),
		
		grab	= src	=> [...src.children].reduce((a,n)=>{if(n.id)a[n.id]=src.removeChild(n); return a},{}),

		dataset	= (tags,raws)=>raws.map( raw=>{const row={};tags.forEach((t,i)=>row[t]=raw[i]); return row;} ),
		
		db	=(function(){ // dap wrapper for Persist object
					
				const	P	=Persist(localStorage,dap.Env.Json.encode,dap.Env.Json.decode,true),
					T	=(tables=> key=>tables[key]||(tables[key]=P(key)) )({}),
					detach=r=>{r=Object.assign({},r);if(r[""])delete r[""];return r},
					filter=(data,values,tags)	=> !values.length?data:values.reduce((a,v,i)=>a.length?a.filter(r=>r[tags[i]]==v):a,data),	// :[]
					join	=(row,values,tags)	=> row&&Object.assign({}, row, ...values.map((v,i)=>T(tags[i]).take(v))),	// :{}
					save	=(table,values)		=> values.forEach(r=>table.save(detach(r)))||table.data();
					
				return	(values,tags)=>{
					const	v=values.pop(),
						c=values.length,
						t=tags[c-1],
						a=tags[c];
						
					return	!a ? filter(T(v).data(),values,tags) :				// ( `key $x $y ... )
							!v ? save(T(a),values) :						// ( @key $row1 $row2 ... )
							!t ? c?T(a).take(v):join(T(a).take(v),values,tags) :		// ( $key `t1 `t2 ... )
							values.push(v) && T(a).save(dap.Util.hash(values,tags));	// ( $key $x $y ... )
				} //( @ ... ) reserved
			})()
	;

	'client'.d("$tab= $Entity=; $entries= $aspects= $entities= $opinions= $cats= $lists= $listentities="
	
			,'page.nav'.d(""
			
				,'tabs'.d("* dict.tabs@"
					,'tab'.d("! .title; a!").a("!? (.tab $tab)eq@selected").ui("$tab=.tab")
				)
				
				,'ARTICLE.lists'.d("?? $tab@lists; $list="
					,'select'.d("$lists; *@ (`list)db"
						,'option'.d("! .title").a("!? (.list $list)eq@selected").ui("$list=.")
					)
					,'add'.ui("? .title=(dict.prompt.addlist)prompt; $lists=(@list (.title))db")
					,'UL.entities'.d("? $list; * (`listentity $list)db"
						,'LI'	.d("? .tagged; .Entity=(.entity)db; ! .Entity.title")
							.a("!? (.Entity $Entity)eq@selected")
							.ui("$Entity=.")
					)
				)
				
				,'ARTICLE.cats'.d("?? $tab@cats; $cat="
					,'select'.d("$cats; *@ (`cat)db"
						,'option'.d("! .title").a("!? (.cat $cat)eq@selected").ui("$cat=.")
					)
					,'add'.ui("? .title=(dict.prompt.addlist)prompt; $cats=(@cat (.title))db")
					,'UL.entities'.d("? $cat; * (`entity $cat)db"
						,'LI'.d("? .tagged; .Entity=(.entity)db; ! .Entity.title").ui("$Entity=.")
					)
				)
				
				,'ARTICLE.settings'.d("?? $tab@settings"
					,'BUTTON.clear'.d("! `Clear").ui("storage.clear")
				)
				
				,'ARTICLE.welcome'.d("? $tab:!; ! html.welcome")
				
				
				,'find'.d("$?= $entry="//,'4627073803671'
					,'INPUT.key'.ui("log $entry=#:value,prefix")
					,'BUTTON.scan'.ui("$entry=#:scan,prefix")
			
				).u("? $entry; ? .Entry=($entry)db .Entry=($entry .entity=():?uid)db; ? $Entity=(.Entry.entity)db $Entity=(.Entry.entity $entry@title)db") /// <--tweak this
			)
		
			
			,'page.entity'.d("? $Entity; scroll #; * $Entity@"
					
				,'SECTION.editables'.d(""
					,input("title").d("focus .title:!")
					,input("desc").d("focus (.title .desc:!)!")
					//,'general'.d("! Aspect")
				).u("(@entity $)db")
				
				,'info'.d(""
				
					,'SECTION.tags'.d("$lists; * (`list)db"
						,'tag'
						.d("! .title; .?=(.listentity=(.list .entity=$Entity.entity)~)db $tagged=.?.; a!")
						.a("!? $tagged")
						.ui("(.listentity .list .entity $tagged:?uid=$tagged:!)db")
					)
					
					,'SECTION.entries'.d("* (`entry .entity)db"
						,'A.entry target=_blank'.d("!! .entry@ .entry@href")
					)
					
					
					//,'BUTTON.bindto'.d("! `Bind")
				
		/*				,'SELECT.category'
						.d("? $entity.aspects:!; hint dict.entity.category; Options(mock.categories:)")
						.ui(".aspects=#:value")
					,'aspects'.d("Aspects($entity.aspects)")
		*/			
					,'SECTION.aspects'.d(""
						,'opinions'.d("$opinions; * (`opinion .entity)db"
							,'opinion'.d("! Aspect").u("(@opinion $)db")
						)
						,'opinion'.d("$?="
							,'BUTTON.add'.d("? $?:!").ui("$?=:!")
							,'SELECT.name'
							.d("? $?; hint dict.entity.aspects; * mock.aspect; Option(.aspect@value)")//; #:focus
							.ui(" $?= .aspect=#:value $opinions=(.opinion=(.entity .aspect)~ .entity .aspect)db")//$opinions=()
						)
					)
				)
			)

	)

	.DICT({
	
		Aspect	: 'aspect'.d("$?="
				,'summary'.d(""
					,'name'.d("! .aspect").ui("$?=$?:!; ?")
					,'IMG.stats'.d()
					,'credit'.d("! $!=.credit:starbar.enabled").ui("$?=.credit=$!.value")
				)
				,'notes'.d(""
					,'public'.d("? $?; ? .ref; * (`notes .ref)db"
						,'note'.d("! .note").ui("..note=. ..publicnote=.")
					)
					,'note contenteditable'
						.d("? (.note $?)?; ! .note; focus (.note:! $?)!")
						.ui(".note=#:text")//? (.note .publicnote:!)?;
				).u("$?=")
			),					

		Options	: 'OPTGROUP'.d("! (.selected:! Hint)!; * .options@value; Option( .value ..selected )"), 
		Option	: 'OPTION'.d("!! (.label .value)? .value (.value .selected)eq@selected"),
			
		method	:['barcode','uri'],

		mock	:{
			aspect:['general','taste','nutrition','ethic']
		},
		
		dict	:{
			barcode	:"barcode",
			editable:{
				title	:"Entity title",
				credit:"Credit",
				note	:"Note",
				aspects	:"Applicable aspects"
			},
			tabs	: dataset(
					["tab","title"],
					[["lists","Списки"],["cats","Категории"],["settings","Настройки"]]
				)
		},
		
		html	:grab(document.getElementById("content"))

	})
	
	.FUNC({
		operate	:{
			hint	:(value,alias,node)=>{node.setAttribute("placeholder",value)},
			storage	:{
				clear	:()=>confirm("Clear all local data?")&&localStorage.clear()
			},
			focus:(value,alias,node)=>{if(value)window.setTimeout(()=>{node.focus()},100)},
			scroll:(value,alias,node)=>{if(value)
					window.setTimeout(()=>{
						//node.offsetParent.parentNode.scrollLeft=node.offsetLeft;
						node.scrollIntoView({behavior:"smooth",inline:"end"});
					},500);
				}
		},
		flatten	:{ db,
			"~"	:values=>values.join(":"),
			trace	:(values,names)=>console.log(values.map((v,i)=>names[i]+": "+v).join("; "))
		},
		convert	:{
			"?uid"	: bool => bool&&uid(),
			starbar	: Starbar(document.createElement("stars"),10),
			prefix	: entry => {
				const	format	={
					"EAN13"	:/^\d{13}$/,
					//"youtube"	:/^(?:https://www.youtube.com/watch?v=)[a-zA-Z0-9-]/,
					"http"	:/.+/,
					"https"	:/.+/
					},
					parts	= entry.split(":"),
					key	= parts.pop(),
					f	= parts.length&&parts.pop();
					
				if(f)return key.match(format[f])?entry:console.log("format mismatch:"+entry);
				else for(let f in format)if(key.match(format[f]))return f+":"+key;
				console.log("Can't recognize key format");
			},			
				
			scan	: _ =>dap.Async(Scan.execute(),"scan")
		}
	})
	
	.FUNC(Persist)
	
	.RENDER()

	</script>

</body>
</html>
<script>
</script>